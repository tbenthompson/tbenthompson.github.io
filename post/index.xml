<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>New posts from T. Ben Thompson</title><link>https://tbenthompson.com/post/</link><description>Recent content from tbenthompson.com</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 07 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://tbenthompson.com/post/index.xml" rel="self" type="application/rss+xml"/><item><title>FAQ: Why should research scientists be at the center of our scientific workforce?</title><link>https://tbenthompson.com/post/reasons_for_research_scientists/</link><pubDate>Fri, 07 Jan 2022 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/reasons_for_research_scientists/</guid><description>Ideally, this will be a living document. I just hit publish on this because I&amp;rsquo;m impulsive but it probably needs some serious editing. This was last updated on 1/7/2022.
In most research settings, research scientists are the central characters. In industrial research, experienced research scientists and engineers are well paid and prestigious. In national labs, the main career path is as a research scientist. But in academia, research scientists are few and far between.</description></item><item><title>We need technical research consultants.</title><link>https://tbenthompson.com/post/technical_research_consulting/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/technical_research_consulting/</guid><description>Prelude: Research scientists and research consultants. This is a proposal for a new type of research organization that would provide technical support, particularly on things like lab equipment or computational methods or software: technical competencies that take a long time to develop and are mostly independent of the particular lab environment.
There&amp;rsquo;s a spectrum of hands-on technical researchers. On the one hand, research scientists are full-time technically talented team members that execute on research plans.</description></item><item><title>Open source release! Generalized linear modeling with glum and tabmat.</title><link>https://tbenthompson.com/post/glum_tabmat/</link><pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/glum_tabmat/</guid><description>I&amp;rsquo;m super excited to announce the release of glum and tabmat. These are the first two open source projects that QuantCo has released! Hopefully there will be many more. glum is a efficient and featureful Python-first library for generalized linear model (GLM) estimation built with an sklearn-style API. We focused a ton on correctness, performance and satisfying a wide range of feature requirements.
While working on this project, my coworkers and I heard repeatedly from folks on other data science or economics teams that they either struggled with the same GLM software problems we had or they had built their own internal GLM tool similar to glum.</description></item><item><title>50 suggestions on correctness and testing for scientific software for PDEs</title><link>https://tbenthompson.com/post/testing_scientific_software/</link><pubDate>Fri, 09 Jul 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/testing_scientific_software/</guid><description>I think testing and debugging is one of the harder aspects of scientific and numerical software. It&amp;rsquo;s easy to get buried in giant pile of code and have no idea where to look for bugs. It&amp;rsquo;s even harder when actually the bug isn&amp;rsquo;t in the code but is in the concepts, math or data.
The fundamental problem with testing and debugging scientific software is that we don&amp;rsquo;t know correct intermediate values or even the correct final output.</description></item><item><title>Gaussian quadrature is not optimal</title><link>https://tbenthompson.com/post/better_than_gauss/</link><pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/better_than_gauss/</guid><description>It&amp;rsquo;s conventional wisdom that Gaussian quadrature is the most point-efficient quadrature formula for analytic functions. But, it&amp;rsquo;s not true! &amp;ldquo;New quadrature formulas from conformal maps&amp;rdquo; by Hale and Trefethen (2008) demonstrates that it&amp;rsquo;s possible to have quadrature formulas that converge about 50% faster for analytic functions. The paper is quite accessible and I encourage you to read it, but I also wanted to help bring attention to it since it seems like it should be more well-known.</description></item><item><title>Reflective deep work</title><link>https://tbenthompson.com/post/reflective_deep_work/</link><pubDate>Fri, 11 Jun 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/reflective_deep_work/</guid><description>You might also call this introspective deep work, or self-reflective deep work.
I just finished reading Deep Work and it has me thinking about applying a few of the concepts well beyond my career. &amp;ldquo;Deep work&amp;rdquo; is all about making space for the hard intellectual work at the core of most knowledge workers&amp;rsquo; jobs. But, the concept of making space in your day or week or month for deep thought seems like it should apply well beyond my career.</description></item><item><title>Why it's okay to share your code</title><link>https://tbenthompson.com/post/share_your_code/</link><pubDate>Mon, 17 May 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/share_your_code/</guid><description>TL;DR: If you write a paper that involves complex code, share your code freely online. Don&amp;rsquo;t make it pretty. Don&amp;rsquo;t make it easy to use. Refuse to support the code. Just share it!
People have talked a lot already about why it&amp;rsquo;s a good idea to share code with your research. I want to address a specific component of this. The desire to share good, well-maintained code often becomes a barrier to sharing any code at all.</description></item><item><title>Maintaining momentum</title><link>https://tbenthompson.com/post/maintaining_momentum/</link><pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/maintaining_momentum/</guid><description>Collaboration in an unstructured world While I haven&amp;rsquo;t made any decisions yet, I&amp;rsquo;m currently considering heading off into a much less structured career path which could be variously described as &amp;ldquo;independent scientist&amp;rdquo;, &amp;ldquo;entrepreneuer&amp;rdquo;, &amp;ldquo;contractor&amp;rdquo; or &amp;ldquo;self-employed open-source developer&amp;rdquo;. Along those lines, I&amp;rsquo;ve been wondering what makes work good for me and how I can put the pieces together reliably. I think the critical piece will be to proactively communicate with lots of people.</description></item><item><title>Maybe we should stop using planar triangles for fault modeling</title><link>https://tbenthompson.com/post/surface_representation/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/surface_representation/</guid><description>Let&amp;rsquo;s consider a model problem where the goal is to calculate the stress on a fault due to some slip on that fault. We also include a topographic free surface. How should we model this surface?
Should we use planar triangles to model a curved fault? What happens at the junction between two triangles? If we do the natural fault thing and require the slip to be tangential to the suface, the slip vector has a step function at the junction between the two triangles.</description></item><item><title>Cool video of Cascadia earthquake cycle simulations</title><link>https://tbenthompson.com/post/cascadia/</link><pubDate>Tue, 02 Apr 2019 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/cascadia/</guid><description/></item><item><title>130 million triangular dislocations per second with Python/CUDA</title><link>https://tbenthompson.com/post/cutde/</link><pubDate>Thu, 26 Jul 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/cutde/</guid><description>See the GitHub repo</description></item><item><title>CLUDA - Write once, run anywhere with both CUDA and OpenCL.</title><link>https://tbenthompson.com/post/cluda/</link><pubDate>Mon, 02 Apr 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/cluda/</guid><description>See the GitHub repo</description></item><item><title>Regularizing rate and state friction for numerical simulation</title><link>https://tbenthompson.com/post/regularized_rate_state/</link><pubDate>Mon, 19 Mar 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/regularized_rate_state/</guid><description>The standard form for rate and state friction produces undefined results for $V = 0$. Some algebra and calculus and microphysics lead to the commonly used regularized form that is still valid at $V=0$. This is based on the presentation in Rice and Ben-Zion 1996 and Lapusta et. al 2000. There&amp;rsquo;s nothing novel here, but the details of this sort of thing are often glossed over in the literature. So, while working it out for myself, I figured I&amp;rsquo;d write it up!</description></item><item><title>A quasidynamic spring block slider</title><link>https://tbenthompson.com/post/block_slider/</link><pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/block_slider/</guid><description>source available here
Figures first, explanations later!
Recently, I&amp;rsquo;ve been working on some 3D quasidynamic earthquake modeling problems. We&amp;rsquo;re planning to add in some realistic geometries using tectosaur to see what influence that has on the earthquake cycle. While putting together that 3D model, I realized that it consists of two main pieces:
The numerical methods for determining traction on the fault surface given the current values of slip everywhere on the fault (elasticity!</description></item><item><title>Cloudpickle, serializing functions and monkey patching</title><link>https://tbenthompson.com/post/cloudpickle_monkey_patching/</link><pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/cloudpickle_monkey_patching/</guid><description>I&amp;rsquo;ve been using cloudpickle in the internals of taskloaf for a while since it allows serializing almost all functions and objects. That&amp;rsquo;s really nice since it means I can pass arbitrary functions (tasks, jobs) from one worker to another across the network.
Yesterday, I was curious about the internals of cloudpickle and whether a monkey-patched object would remain patched after being loaded remotely. I read a bit of the source, but figured just trying it was a good idea.</description></item><item><title>My Python testing set up</title><link>https://tbenthompson.com/post/how_i_test/</link><pubDate>Thu, 22 Feb 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/how_i_test/</guid><description>To follow up on the last post about testing for science and data analytics, I thought it&amp;rsquo;d be nice to talk about the specific tools I use for testing. I don&amp;rsquo;t claim this is the best way to do things, but it tends to work pretty well for small projects and teams.
py.test The py.test tool is handy for running a suite of tests in python. It&amp;rsquo;s a very general tool for running all the tests in a project.</description></item><item><title>Automated testing for scientists and data analysts</title><link>https://tbenthompson.com/post/automated_testing_for_science/</link><pubDate>Wed, 07 Feb 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/automated_testing_for_science/</guid><description>A lot of scientists and data analysts don&amp;rsquo;t use automatic test suites for verifying their code. And I think that&amp;rsquo;s because it&amp;rsquo;s really hard. Almost all the introductions to automated testing that I&amp;rsquo;ve seen come from a more typical software engineering perspective. They assume you already know exactly what the output of your code should be. And the trouble with science is that that&amp;rsquo;s rarely the case. I mean, if you knew the results ahead of time, you wouldn&amp;rsquo;t be doing science!</description></item><item><title>Sneaky (transparent) huge pages</title><link>https://tbenthompson.com/post/sneaky-transparent-huge-pages/</link><pubDate>Wed, 17 Jan 2018 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/sneaky-transparent-huge-pages/</guid><description/></item><item><title>Sparse n-body matrices</title><link>https://tbenthompson.com/post/sparse_nbody/</link><pubDate>Sat, 02 Jul 2016 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/sparse_nbody/</guid><description>This is a sparsity plot of a matrix representing an approximate n-body interaction. The black dots are non-zeros in the matrix. Imagine 2000 stars, each exerting some gravitational pull on each of the other stars. This gravitational interaction could be represented by a dense matrix:
$$ A_{ij} = \frac{G m_i m_j}{|\mathbf{x}_i - \mathbf{x}_j|^2} $$
This works, but dense matrices can be slow when there are many stars. The cost of evaluating a matrix-vector product will scale like $O(n^2)$.</description></item><item><title>"Serializing" a function in C++</title><link>https://tbenthompson.com/post/serialize_fnc_cpp/</link><pubDate>Wed, 23 Dec 2015 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/serialize_fnc_cpp/</guid><description/></item><item><title>Setting up my website</title><link>https://tbenthompson.com/post/setting_up_website/</link><pubDate>Fri, 11 Dec 2015 00:00:00 +0000</pubDate><guid>https://tbenthompson.com/post/setting_up_website/</guid><description>I have a website now. Since technical stuff is fun, I thought I&amp;rsquo;d share the way I set it up.
The site is a set of statically served HTML pages. Hugo makes this really easy. Hugo is super fast and is written in Go. You can set up a few template pages and then write posts and pages in Markdown. Some layout is also done using Go templates. Running Hugo takes your templates and pages and concerts them into static HTML.</description></item></channel></rss>